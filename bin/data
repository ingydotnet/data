#!/usr/bin/env perl

use strict;
use FindBin;
use Pegex::Parser;
use Pegex::Grammar;
use IO::All;
use YAML::XS qw/ Dump /;
use Getopt::Long;
use XXX;

sub main {
    my @args = @_;
    GetOptions(
        "from=s" => \my $from,
        "yaml" => \my $output_yaml,
        "path=s" => \my $path,
    );

    my ($grammar_text, $receiver);
    if ($from eq "ifconfig") {
        $grammar_text = io("$FindBin::Bin/../share/ifconfig.pgx")->all;
        $receiver = Ifconfig->new;
    }
    elsif ($from eq "mount") {
        $grammar_text = io("$FindBin::Bin/../share/mount.pgx")->all;
        $receiver = Mount->new;
    }
    my $input = io('-')->all;

    my $grammar = Pegex::Grammar->new(text => $grammar_text);
    my $parser = Pegex::Parser->new(
        grammar => $grammar,
        receiver => $receiver,
        debug => 1,
    );

    # XXX $grammar->tree->{hwaddr};

#    XXX $parser->parse($input);
    my $data = $parser->parse($input);
    if (defined $path and length $path) {
        while (length $path) {
            if ($path =~ s/^\[(\d+)\]//) {
                my $index = $1;
                $path =~ s{^/}{};
                $data = $data->[ $index ];
            }
            elsif ( $path =~ s{^ ([^/\[]+ ) }{}x ) {
                my $key = $1;
                $path =~ s{^/}{};
                $data = $data->{ $key };
            }
            else {
                $data = $data->{ $path };
                last;
            }
        }
    }

    my $output = ref $data ? Dump $data : $data;
    print $output . "\n";
}

package Data;
use base 'Pegex::Tree';

sub initial {
    my ($self) = @_;
    $self->{data} = {};
}

sub final {
    my ($self) = @_;
    return $self->{data};
}

package Mount;
use base 'Data';
use XXX;

sub got_mount_options {
    my ($self, $got) = @_;
    +{ 'Options' => $got };
}

sub got_mount_point {
    my ($self, $got) = @_;
    +{ 'Mount Point' => $got };
}

sub got_mount_name {
    my ($self, $got) = @_;
    +{ 'Mount Name' => $got };
}

sub got_fs_type {
    my ($self, $got) = @_;
    +{ 'FS Type' => $got };
}

sub got_mount_entry {
    my ($self, $got) = @_;
    my (@data) = @$got;
    my %hash = map %$_, @data;
    my $name = delete $hash{"Mount Point"};
    $self->{data}{$name} = \%hash;
}


package Ifconfig;
use base 'Data';
use XXX;


sub got_device_section {
    my ($self, $got) = @_;
    my ($name, $section) = @$got;
    $section = $self->flatten($section);
    my %hash = map %$_, @$section;
    $self->{data}{$name} = \%hash;
}

sub got_inet_addr {
    my ($self, $got) = @_;
    +{ 'IP Address' => $got };
}

sub got_inet6_addr {
    my ($self, $got) = @_;
    +{ 'IP6 Address' => $got };
}

sub got_bcast {
    my ($self, $got) = @_;
    +{ 'Broadcast' => $got };
}

sub got_mask {
    my ($self, $got) = @_;
    +{ 'IP Mask' => $got };
}

sub got_scope {
    my ($self, $got) = @_;
    +{ 'Scope' => $got };
}

sub got_mtu {
    my ($self, $got) = @_;
    +{ 'MTU' => $got };
}

sub got_metric {
    my ($self, $got) = @_;
    +{ 'Metric' => $got };
}

sub got_collisions {
    my ($self, $got) = @_;
    +{ 'Collisions' => $got };
}

sub got_txqueuelen {
    my ($self, $got) = @_;
    +{ 'TX Queue Length' => $got };
}

sub got_rx_bytes {
    my ($self, $got) = @_;
    +{ 'RX Bytes' => $got };
}

sub got_tx_bytes {
    my ($self, $got) = @_;
    +{ 'TX Bytes' => $got };
}

sub got_link_encap {
    my ($self, $got) = @_;
    +{ 'Link Encap' => $got };
}

sub got_hwaddr {
    my ($self, $got) = @_;
    +{ 'Hardware Address' => $got };
}

sub got_flags {
    my ($self, $got) = @_;
    +{ map { $_ => 1 }  split ' ', $got };
}

sub got_rx {
    my ($self, $got) = @_;
    my %hash = map { %$_ } @{ $got ->[0]};
    +{ 'RX' => \%hash };
}

sub got_rx_keys {
    my ($self, $got) = @_;
    +{ @$got };
}

sub got_tx {
    my ($self, $got) = @_;
    my %hash = map { %$_ } @{ $got ->[0]};
    +{ 'TX' => \%hash };
}

sub got_tx_keys {
    my ($self, $got) = @_;
    +{ @$got };
}

sub got_packets {
    my ($self, $got) = @_;
    +{ 'packets' => $got };
}

sub got_errors {
    my ($self, $got) = @_;
    +{ 'errors' => $got };
}

sub got_dropped {
    my ($self, $got) = @_;
    +{ 'dropped' => $got };
}

sub got_overruns {
    my ($self, $got) = @_;
    +{ 'overruns' => $got };
}

sub got_frame {
    my ($self, $got) = @_;
    +{ 'frame' => $got };
}

sub got_carrier {
    my ($self, $got) = @_;
    +{ 'carrier' => $got };
}


sub got_other {}

package main;
main @ARGV;
